#include <list>#include <map>#include "hash/extendible_hash.h"#include "page/page.h"#include "common/logger.h"#define ERROR -1namespace scudb {/* * constructor * array_size: fixed array size for each bucket */    template<typename K, typename V>    ExtendibleHash<K, V>::ExtendibleHash(size_t size) {        this->globalDepth = 0;        this->bucketSize = size;        this->bucketNum = 1;        buckets.push_back(make_shared<Bucket>(0));    }//    template<typename K, typename V>//    ExtendibleHash<K, V>::ExtendibleHash() {////        ExtendibleHash(64);//        this->globalDepth = 0;//        this->bucketSize = 64;//        this->bucketNum = 1;//        buckets.push_back(make_shared<Bucket>(0));//        //缺省默认：新建一个拥有size=64的extendible hash//    }/* * helper function to calculate the hashing address of input key */    template<typename K, typename V>    size_t ExtendibleHash<K, V>::HashKey(const K &key) const {//        return hash < K > {}(key);        /*         * 返回了一个散列函数值，为线型函数         *         */        return (size_t) key;    }/* * helper function to return global depth of hash table * NOTE: you must implement this function in order to pass test */    template<typename K, typename V>    int ExtendibleHash<K, V>::GetGlobalDepth() const {        lock_guard<mutex> lock(latch);        return this->globalDepth;    }/* * helper function to return local depth of one specific bucket * NOTE: you must implement this function in order to pass test */    template<typename K, typename V>    int ExtendibleHash<K, V>::GetLocalDepth(int bucket_id) const {        lock_guard<mutex> lock(latch);        if (buckets[bucket_id]) {            lock_guard<mutex> lck(buckets[bucket_id]->latch);            if (buckets[bucket_id]->keymap.size() != 0) {                return buckets[bucket_id]->localDepth;            }        }        return ERROR;    }/* * helper function to return current number of bucket in hash table */    template<typename K, typename V>    int ExtendibleHash<K, V>::GetNumBuckets() const {        lock_guard<mutex> lock(latch);        return bucketNum;    }/* * lookup function to find value associate with input key */    template<typename K, typename V>    int ExtendibleHash<K, V>::getIndex(const K &key) const {        lock_guard<mutex> lck(latch);        return HashKey(key) & ((1 << globalDepth) - 1);    }    template<typename K, typename V>    bool ExtendibleHash<K, V>::Find(const K &key, V &value) {        int curIndex = getIndex(key);        lock_guard<mutex> lck(buckets[curIndex]->latch);        if (buckets[curIndex]->keymap.find(key) != buckets[curIndex]->keymap.end()) {            value = buckets[curIndex]->keymap[key];            return true;        }        return false;    }/* * delete <key,value> entry in hash table * Shrink & Combination is not required for this project */    template<typename K, typename V>    bool ExtendibleHash<K, V>::Remove(const K &key) {        int curIndex = getIndex(key);        lock_guard<mutex> lck(buckets[curIndex]->latch);        shared_ptr<Bucket> cur = buckets[curIndex];        if (cur->keymap.find(key) == cur->keymap.end()) {            return false;        } else {            cur->keymap.erase(key);            return true;        }    }/* * insert <key,value> entry in hash table * Split & Redistribute bucket when there is overflow and if necessary increase * global depth */    template<typename K, typename V>    void ExtendibleHash<K, V>::Insert(const K &key, const V &value) {//        LOG_INFO("插入\n");        int curIndex = getIndex(key);//        LOG_INFO("here1，index = %d\n", curIndex);//        LOG_INFO("bucket size = %zu\n",buckets.size());        shared_ptr<Bucket> curBucket = buckets[curIndex];//        LOG_INFO("true");        while (true) {//            LOG_INFO("while(1)");            lock_guard<mutex> lck(curBucket->latch);            if (curBucket->keymap.find(key) != curBucket->keymap.end() || curBucket->keymap.size() < bucketSize) {                curBucket->keymap[key] = value;                break;            }            int mask = (1 << (curBucket->localDepth));            curBucket->localDepth++;            {                lock_guard<mutex> lck2(latch);                if (curBucket->localDepth > globalDepth) {                    size_t length = buckets.size();                    for (size_t i = 0; i < length; i++) {                        buckets.push_back(buckets[i]);                    }                    globalDepth++;                }                bucketNum++;                auto newCurBucket = make_shared<Bucket>(curBucket->localDepth);                typename map<K, V>::iterator it;                for (it = curBucket->keymap.begin(); it != curBucket->keymap.end();) {                    if (HashKey(it->first) & mask) {                        newCurBucket->keymap[it->first] = it->second;                        it = curBucket->keymap.erase(it);                    } else {                        it++;                    }                }                for (size_t i = 0; i < buckets.size(); i++) {                    if (buckets[i] == curBucket && (i & mask))                        buckets[i] = newCurBucket;                }            }            curIndex = getIndex(key);            curBucket = buckets[curIndex];        }    }    template    class ExtendibleHash<page_id_t, Page *>;    template    class ExtendibleHash<Page *, std::list<Page *>::iterator>;// test purpose    template    class ExtendibleHash<int, std::string>;    template    class ExtendibleHash<int, std::list<int>::iterator>;    template    class ExtendibleHash<int, int>;} // namespace scudb